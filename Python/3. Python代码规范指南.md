# Python 代码规范指南

基于 PEP 8 (代码风格指南) 和 PEP 257 (文档字符串规范) 的完整 Python 代码规范总结。

## 目录
1. [核心原则](#核心原则)
2. [代码布局](#代码布局)
3. [字符串引号](#字符串引号)
4. [表达式和语句中的空格](#表达式和语句中的空格)
5. [注释规范](#注释规范)
6. [文档字符串 (Docstrings)](#文档字符串-docstrings)
7. [命名规范](#命名规范)
8. [编程建议](#编程建议)
9. [函数注解](#函数注解)
10. [工具配置](#工具配置)

---

## 核心原则

### 愚蠢的一致性是小心眼的妖精 (A foolish consistency is the hobgoblin of little minds)

- **代码的可读性最重要** - 代码被阅读的频率远高于编写频率
- **一致性层次**：
  1. 项目内一致性 > 风格指南一致性
  2. 模块内一致性 > 项目一致性  
  3. 函数内一致性 > 模块一致性

### 何时忽略风格指南

- 应用指南会使代码可读性变差
- 为了与周围代码保持一致
- 代码早于指南存在且没有修改理由
- 需要兼容旧版本 Python

---

## 代码布局

### 缩进

**使用 4 个空格作为缩进单位**

```python
# 正确：与开始分隔符对齐
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# 正确：增加 4 个空格以区分参数
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)

# 正确：悬挂缩进
foo = long_function_name(
    var_one, var_two,
    var_three, var_four)
```

```python
# 错误：不使用垂直对齐时，第一行禁止有参数
foo = long_function_name(var_one, var_two,
    var_three, var_four)

# 错误：缩进不够明显
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)
```

### 制表符还是空格？

- **优先使用空格**
- 制表符仅用于与已使用制表符的代码保持一致
- Python 3 禁止混合使用制表符和空格

### 行长度限制

- **所有行限制在 79 个字符以内**
- **文档字符串和注释限制在 72 个字符**
- 团队可协商使用 99 个字符，但注释仍需 72 个字符

```python
# 正确：使用括号进行隐式换行
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)

# 必要时使用反斜杠
with open('/path/to/some/file/you/want/to/read') as file_1, \
     open('/path/to/some/file/being/written', 'w') as file_2:
    file_2.write(file_1.read())
```

### 二元运算符换行

**在二元运算符之前换行（数学传统）**

```python
# 正确：运算符和操作数容易匹配
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
```

```python
# 错误：运算符远离操作数
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)
```

### 空行规则

- **顶级函数和类定义前后使用两个空行**
- **类内方法定义前后使用一个空行**
- **相关函数组之间可使用额外空行（谨慎使用）**
- **函数内部谨慎使用空行分隔逻辑段落**

### 源文件编码

- **核心代码应使用 UTF-8**
- **不应有编码声明**
- **标准库中非 UTF-8 编码仅用于测试**
- **标识符必须使用纯 ASCII 字符**

### 导入

```python
# 正确：分别导入
import os
import sys

# 正确：可以这样写
from subprocess import Popen, PIPE

# 错误：不要这样
import sys, os
```

**导入顺序**：
1. 标准库导入
2. 相关第三方库导入
3. 本地应用/库导入

**每组之间用空行分隔**

```python
# 正确：绝对导入
import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example

# 可接受：相对导入
from . import sibling
from .sibling import example

# 避免：通配符导入
from module import *  # 不推荐
```

### 模块级 Dunder 名称

```python
"""模块文档字符串."""

from __future__ import barry_as_FLUFL

__all__ = ['a', 'b', 'c']
__version__ = '0.1'
__author__ = 'Cardinal Biggles'

import os
import sys
```

---

## 字符串引号

- **单引号和双引号字符串相同，选择一种并坚持使用**
- **字符串包含引号时，使用另一种引号避免反斜杠**
- **三重引号字符串总是使用双引号** （与文档字符串规范一致）

```python
# 提高可读性
text = "Don't do that"
message = 'He said "Hello"'

# 文档字符串
def function():
    """这是文档字符串."""
    pass
```

---

## 表达式和语句中的空格

### 避免多余空格

```python
# 正确
spam(ham[1], {eggs: 2})
foo = (0,)
if x == 4: print(x, y); x, y = y, x

# 错误
spam( ham[ 1 ], { eggs: 2 } )
bar = (0, )
if x == 4 : print(x , y) ; x , y = y , x
```

### 切片中的冒号

```python
# 正确
ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
ham[lower:upper], ham[lower:upper:], ham[lower::step]
ham[lower+offset : upper+offset]

# 错误
ham[lower + offset:upper + offset]
ham[1: 9], ham[1 :9], ham[1:9 :3]
```

### 其他建议

```python
# 正确：二元运算符两侧各一个空格
i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)

# 错误
i=i+1
submitted +=1
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)
```

### 函数注解

```python
# 正确
def munge(input: AnyStr) -> PosInt: ...
def munge(sep: AnyStr = None): ...

# 错误
def munge(input:AnyStr): ...
def munge(input: AnyStr=None): ...
```

### 关键字参数

```python
# 正确
def complex(real, imag=0.0):
    return magic(r=real, i=imag)

# 错误
def complex(real, imag = 0.0):
    return magic(r = real, i = imag)

# 有注解时使用空格
def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ...
```

---

## 注释规范

### 基本原则

- **与代码矛盾的注释比没有注释更糟**
- **代码更改时，优先更新注释**
- **注释应该是完整的句子**
- **首词大写（除非是标识符）**
- **使用英语编写注释**

### 块注释

```python
# 块注释通常应用于跟随的代码，并缩进到相同级别。
# 块注释的每一行都以 # 和一个空格开始。
#
# 块注释内的段落由只含单个 # 的行分隔。
def function():
    pass
```

### 行内注释

```python
# 谨慎使用行内注释
x = x + 1                 # 增加 x

# 不要这样做（说明显而易见的事情）
x = x + 1                 # x 递增

# 有时有用
x = x + 1                 # 边界补偿
```

---

## 文档字符串 (Docstrings)

基于 PEP 257 规范。

### 基本规则

- **所有公共模块、函数、类和方法都应有文档字符串**
- **总是使用 `"""三重双引号"""`**
- **一行文档字符串的结束引号在同一行**
- **多行文档字符串的结束引号单独成行**

### 一行文档字符串

```python
def kos_root():
    """Return the pathname of the KOS root directory."""
    global _kos_root
    if _kos_root: return _kos_root
    # ...
```

**要点**：
- 即使适合一行也使用三重引号
- 结束引号在同一行
- 前后都没有空行
- 使用祈使语气描述效果（"Do this", "Return that"）
- 不要重述函数签名

### 多行文档字符串

```python
def complex(real=0.0, imag=0.0):
    """Form a complex number.

    Keyword arguments:
    real -- the real part (default 0.0)
    imag -- the imaginary part (default 0.0)
    """
    if imag == 0.0 and real == 0.0:
        return complex_zero
    # ...
```

**结构**：
1. 概要行（像一行文档字符串）
2. 空行
3. 详细描述

### 不同类型的文档字符串

```python
class MyClass:
    """一个简单的示例类.
    
    该类演示了如何编写类文档字符串。它应该总结类的行为并列出
    公共方法和实例变量。
    """
    
    def __init__(self, name):
        """初始化类实例.
        
        Args:
            name (str): 实例的名称
        """
        self.name = name
    
    def greet(self):
        """返回问候语.
        
        Returns:
            str: 包含问候消息的字符串
            
        Raises:
            ValueError: 如果名称为空
        """
        if not self.name:
            raise ValueError("名称不能为空")
        return f"Hello, {self.name}!"
```

### 模块文档字符串

```python
"""一个一行的模块摘要.

更详细的模块描述。该模块提供了以下功能：
- 功能A：描述
- 功能B：描述

示例:
    典型使用方法：

    $ python example_module.py

属性:
    module_level_variable1 (int): 模块级变量说明
"""
```

---

## 命名规范

### 命名风格

- `b` （单个小写字母）
- `B` （单个大写字母）  
- `lowercase` （小写）
- `lower_case_with_underscores` （小写加下划线）
- `UPPERCASE` （大写）
- `UPPER_CASE_WITH_UNDERSCORES` （大写加下划线）
- `CapitalizedWords` 或 `CamelCase` （驼峰命名）
- `mixedCase` （混合大小写，首字母小写）

### 特殊形式

- `_single_leading_underscore`: 弱内部使用指示
- `single_trailing_underscore_`: 避免与关键字冲突
- `__double_leading_underscore`: 类属性名称修饰
- `__double_leading_and_trailing_underscore__`: 魔术对象或属性

### 具体规范

```python
# 包和模块名：简短、全小写
import mypackage
import mymodule

# 类名：驼峰命名
class MyClass:
    pass

class HTTPServerError:  # 缩写词全大写
    pass

# 函数和变量名：小写加下划线
def my_function():
    pass

variable_name = 1
MAX_OVERFLOW = 100  # 常量：全大写

# 函数参数
def method(self, cls_arg):  # self 用于实例方法
    pass

@classmethod
def class_method(cls):  # cls 用于类方法
    pass

# 私有属性：单下划线前缀
class MyClass:
    def __init__(self):
        self._internal_var = 1
        self.__private_var = 2  # 名称修饰
```

### 避免使用的名称

```python
# 不要使用这些单字符名称
l = 1  # 错误：小写字母 L
O = 1  # 错误：大写字母 O  
I = 1  # 错误：大写字母 I

# 使用这些替代
L = 1  # 正确
```

### 继承设计

```python
class BaseClass:
    """设计继承时的考虑."""
    
    def __init__(self):
        self.public_attr = 1        # 公共属性
        self._protected_attr = 2    # 子类 API
        self.__private_attr = 3     # 仅基类使用

    def public_method(self):
        """公共方法."""
        pass
    
    def _protected_method(self):
        """供子类使用的方法."""
        pass
    
    def __private_method(self):
        """仅供内部使用的方法."""
        pass
```

---

## 编程建议

### 比较操作

```python
# 正确：与单例比较使用 is
if foo is None:
    pass

if foo is not None:
    pass

# 错误
if foo == None:
    pass

if not foo is None:
    pass
```

### 序列检查

```python
# 正确：利用空序列为 False 的特性
if not seq:
    pass

if seq:
    pass

# 错误
if len(seq):
    pass

if not len(seq):
    pass
```

### 类型检查

```python
# 正确：使用 isinstance
if isinstance(obj, int):
    pass

# 错误：直接比较类型
if type(obj) is type(1):
    pass
```

### 函数定义

```python
# 正确：使用 def
def f(x): 
    return 2*x

# 错误：将 lambda 赋值给标识符
f = lambda x: 2*x
```

### 异常处理

```python
# 正确：捕获具体异常
try:
    import platform_specific_module
except ImportError:
    platform_specific_module = None

# 正确：限制 try 子句到最小必要代码
try:
    value = collection[key]
except KeyError:
    return key_not_found(key)
else:
    return handle_value(value)

# 错误：过于宽泛
try:
    return handle_value(collection[key])
except KeyError:
    return key_not_found(key)
```

### 资源管理

```python
# 正确：使用 with 语句
with open('/path/to/file') as f:
    data = f.read()

# 正确：明确上下文管理器用途
with conn.begin_transaction():
    do_stuff_in_transaction(conn)
```

### 返回语句

```python
# 正确：一致的返回语句
def foo(x):
    if x >= 0:
        return math.sqrt(x)
    else:
        return None

# 错误：不一致的返回
def foo(x):
    if x >= 0:
        return math.sqrt(x)
    # 隐式返回 None
```

### 字符串方法

```python
# 正确：使用字符串方法
if foo.startswith('bar'):
    pass

if foo.endswith('baz'):
    pass

# 错误：使用切片
if foo[:3] == 'bar':
    pass
```

### 布尔值比较

```python
# 正确
if greeting:
    pass

# 错误
if greeting == True:
    pass

# 更错误
if greeting is True:
    pass
```

---

## 函数注解

基于 PEP 484 的类型注解规范。

```python
from typing import List, Dict, Optional, Union

def process_items(items: List[str], 
                 config: Dict[str, int] = None) -> Optional[str]:
    """处理项目列表.
    
    Args:
        items: 要处理的字符串列表
        config: 配置字典，可选
        
    Returns:
        处理结果字符串，如果失败则为 None
    """
    if not items:
        return None
    
    # 处理逻辑
    return "processed"

# 变量注解
name: str = "Alice"
age: int
scores: List[float] = [85.5, 92.0, 78.5]

class Student:
    """学生类."""
    
    def __init__(self, name: str, age: int) -> None:
        self.name = name
        self.age = age
    
    def get_info(self) -> Dict[str, Union[str, int]]:
        """获取学生信息."""
        return {"name": self.name, "age": self.age}
```

---

## 工具配置

### Black 配置 (pyproject.toml)

```toml
[tool.black]
line-length = 88
target-version = ['py39']
include = '\.pyi?$'
extend-exclude = '''
/(
  # 排除的目录
  \.eggs
  | \.git
  | \.hg
  | \.mypy_cache
  | \.tox
  | \.venv
  | build
  | dist
)/
'''
```

### Pylint 配置 (.pylintrc)

```ini
[MASTER]
disable=C0114,C0115,C0116,R0903

[FORMAT]
max-line-length=88
indent-string='    '

[MESSAGES CONTROL]
disable=missing-docstring,invalid-name,too-few-public-methods

[DESIGN]
max-args=7
max-locals=15
max-returns=6
max-branches=12
```

### Flake8 配置 (setup.cfg)

```ini
[flake8]
max-line-length = 88
extend-ignore = E203, W503
exclude = 
    .git,
    __pycache__,
    build,
    dist,
    .eggs,
    *.egg-info,
    .tox,
    .venv
```

### isort 配置 (pyproject.toml)

```toml
[tool.isort]
profile = "black"
multi_line_output = 3
include_trailing_comma = true
force_grid_wrap = 0
use_parentheses = true
ensure_newline_before_comments = true
line_length = 88
```

### VS Code 设置 (settings.json)

```json
{
    "python.formatting.provider": "black",
    "python.linting.enabled": true,
    "python.linting.pylintEnabled": true,
    "python.linting.flake8Enabled": true,
    "python.linting.mypyEnabled": true,
    "editor.formatOnSave": true,
    "editor.rulers": [79, 88],
    "python.sortImports.args": [
        "--profile", "black"
    ]
}
```

---

## 代码示例

### 完整示例

```python
"""用户管理模块.

该模块提供用户相关的功能，包括用户创建、验证和管理。

Example:
    基本用法:
    
    >>> user = User("Alice", "alice@example.com")
    >>> user.is_valid()
    True

Attributes:
    DEFAULT_ROLE (str): 默认用户角色
"""

from typing import List, Optional, Dict, Union
import re
from datetime import datetime

DEFAULT_ROLE = "user"


class User:
    """用户类.
    
    表示系统中的用户实体，包含基本信息和操作方法。
    
    Attributes:
        name: 用户名称
        email: 用户邮箱
        role: 用户角色
        created_at: 创建时间
    """
    
    def __init__(self, name: str, email: str, role: str = DEFAULT_ROLE) -> None:
        """初始化用户实例.
        
        Args:
            name: 用户名称，不能为空
            email: 用户邮箱地址
            role: 用户角色，默认为 'user'
            
        Raises:
            ValueError: 当名称或邮箱无效时
        """
        if not name.strip():
            raise ValueError("用户名不能为空")
        
        if not self._is_valid_email(email):
            raise ValueError("无效的邮箱地址")
        
        self.name = name.strip()
        self.email = email.lower()
        self.role = role
        self.created_at = datetime.now()
    
    def _is_valid_email(self, email: str) -> bool:
        """验证邮箱格式.
        
        Args:
            email: 要验证的邮箱地址
            
        Returns:
            bool: 邮箱格式是否有效
        """
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return bool(re.match(pattern, email))
    
    def is_admin(self) -> bool:
        """检查用户是否为管理员.
        
        Returns:
            bool: 用户是否具有管理员权限
        """
        return self.role == "admin"
    
    def get_display_name(self) -> str:
        """获取显示名称.
        
        Returns:
            str: 格式化的显示名称
        """
        return f"{self.name} ({self.email})"
    
    def to_dict(self) -> Dict[str, Union[str, datetime]]:
        """转换为字典格式.
        
        Returns:
            dict: 包含用户信息的字典
        """
        return {
            "name": self.name,
            "email": self.email,
            "role": self.role,
            "created_at": self.created_at,
        }
    
    def __str__(self) -> str:
        """字符串表示."""
        return f"User(name='{self.name}', email='{self.email}')"
    
    def __repr__(self) -> str:
        """官方字符串表示."""
        return (
            f"User(name='{self.name}', email='{self.email}', "
            f"role='{self.role}')"
        )


class UserManager:
    """用户管理器.
    
    管理多个用户实例，提供创建、查询和验证功能。
    """
    
    def __init__(self) -> None:
        """初始化用户管理器."""
        self._users: List[User] = []
    
    def add_user(self, user: User) -> None:
        """添加用户.
        
        Args:
            user: 要添加的用户实例
            
        Raises:
            ValueError: 当用户已存在时
        """
        if self.get_user_by_email(user.email) is not None:
            raise ValueError(f"邮箱 {user.email} 已存在")
        
        self._users.append(user)
    
    def get_user_by_email(self, email: str) -> Optional[User]:
        """根据邮箱查找用户.
        
        Args:
            email: 用户邮箱
            
        Returns:
            User 实例或 None（如果未找到）
        """
        email = email.lower()
        for user in self._users:
            if user.email == email:
                return user
        return None
    
    def get_admin_users(self) -> List[User]:
        """获取所有管理员用户.
        
        Returns:
            管理员用户列表
        """
        return [user for user in self._users if user.is_admin()]
    
    def get_user_count(self) -> int:
        """获取用户总数.
        
        Returns:
            用户总数
        """
        return len(self._users)


# 使用示例
if __name__ == "__main__":
    # 创建用户管理器
    manager = UserManager()
    
    # 创建用户
    try:
        alice = User("Alice Smith", "alice@example.com")
        bob = User("Bob Johnson", "bob@example.com", "admin")
        
        manager.add_user(alice)
        manager.add_user(bob)
        
        print(f"用户总数: {manager.get_user_count()}")
        print(f"管理员数量: {len(manager.get_admin_users())}")
        
    except ValueError as e:
        print(f"错误: {e}")
```

---

## 总结

遵循这些代码规范可以：

1. **提高代码可读性** - 一致的风格让代码更容易理解
2. **减少维护成本** - 规范的代码更容易维护和修改
3. **促进团队协作** - 统一的标准让团队成员更容易协作
4. **减少错误** - 良好的命名和结构减少编程错误
5. **提升专业形象** - 规范的代码体现编程水平

**记住**：这些是指导原则，不是绝对的法律。在特殊情况下，可读性和实用性比严格遵循规则更重要。

**推荐工具**：
- **Black**: 自动代码格式化
- **Pylint**: 代码质量检查
- **Flake8**: 风格检查
- **isort**: 导入排序
- **mypy**: 类型检查